#ifndef __BP_NODE_HPP
#define __BP_NODE_HPP

//============================================================================//
//====// Includes //==========================================================//

#include "generic.hpp"
//#include "transform.hpp"
#include "solution.hpp"
#include "bp_graph.hpp"

#include "../ca_graph.hpp"

#include <ilcplex/ilocplex.h>
#include <string>
#include <iostream>
#include <vector>

#define RC_EPS 1e-6


//============================================================================//
//====// Enumerations and Structures //=======================================//

/* Here for documentation purpose.
 * Properly declared in generic.hpp.
 */
/* namespace bp {
	//using   Generator = IloNumArray(gc::ca_graph, IloNumArray);
	typedef IloNumArray (*Generator)(gc::ca_graph, IloNumArray);
	//    |^|New Column|^|         |^|_currentGraph, reduced|^|
	//                             |^|  cost of the master  |^|
	//                             |^|         problem      |^|	

	enum GenMode {
		GM_SELF   = 0, // Use this class methods to find a new column. (default)
		GM_EXTERN = 1  // Use a given extern function to find a new column.
	};

	enum NodeStatus {
		ND_UNINITIALIZED = 0, // The node have just been created and you should
			              // call init() next.
		ND_INITIALIZED   = 1, // The node initialiszed but not the models and
			              // solvers have to be initialize.
		ND_READY         = 2, // The node is ready. You can call solve().
		ND_SOLVED        = 3, // The problem is solved!
		ND_TERMINATED    = 4, // The environment has been destroyed. #TooReal
		ND_VALIDATED     = 5, // TERMINATED and all _child VALIDATED.
		ND_ERROR         = 6  // An error has occured at some point.
	};
}
*/

using namespace std;
//============================================================================//
//====// Main Class //========================================================//

class BP_node {
	
	/// ATTRIBUTES ///
	private:
	//>> Static cpt
	static int          _cpt;                 // Unique Identifier cpt

	//>> Reference to the graph
	BP_graph*           _graph;               // Pointer to the graph to 
	                                          // which this node belongs.

	//>> About the node
	int                 _id;                  // Unique Identifier
	bp::NodeStatus      _status;              // Store the current state 
	bp::Transformation  _lastTransformation;  //   _parent 
	                                          // + _lastTransformation 
	                                          // = this
	BP_node*            _parent;
	vector<BP_node*>    _children;
	//TransformationTable _transformationTable; // All known applied 
	                                          // tranformations are in this.
	ColumnManager*      _CM;	          // All known columns are in 
	                                          // this.
	//>> About the solver
	gc::ca_graph        _currentGraph;        // Graph generated by the
	                                          // transformation table.
	IloEnv              _env;                 // Environment variable
	                                          // common to both our
	                                          // problems.
	IloModel            _masterModel;         // Master problem
	IloModel            _generatorModel;      // Generator problem
	IloObjective        _masterObj;           // Master's objective
	IloObjective        _generatorObj;        // Generator's objective
	IloRangeArray       _masterRange;         // Master range for vertices
	IloCplex            _masterSolver;        // Solvers
	IloCplex            _generatorSolver;     // |^/
	IloNumVarArray      _masterVector;        // Decision vectors 
	IloNumVarArray      _generatorVector;     // |^/


	//>> About the generator
	bp::Generator           _generator;       // Pointer of function
	                                          // see "Enumerations and ...".
	bp::GenMode             _genMode;         // Select the generation mode.

	//>> About the solution
	Solution*               _sol;             // Retrieved solution
	
	/// CONSTRUCTORS ///
	public:
	BP_node(); /* 
	* Default constructor. No use so far.
	*/

	BP_node(BP_graph* g); /*
	* Create a root for g.	
	*/

	BP_node(BP_node* p, bp::Transformation t); /*
	* Create the child of p by t.
	*/
	
	/// METHODS ///
	public:
	void branch(int u = -1, int v = -1); /*
	* Branch on (u,v) with the Zykov's methods :
	* G.branch(u,v) => G(E) U {(u,v)}, 
	*                  (G(V)\{u,v}) U {i} with i = join(u,v)
	* If one or more target nodes are missing, the missing ones are
	* automaticly selected by _selectBranch().
	* This method creates 2 BP_nodes. They are added to the _graph and
	* a vector of pointers to this new nodes is returned and stored in
	* _children.
	* Both BP_nodes have a fully filled _transformationTable and relevent 
	* data but are solver-wise uninitialized. 
	* (see "About the solver" in "Attributes").
	*/

	void init(); /*
	* Initialize the _currentGraph thanks to the _transformationTable
	* and create a conversion table from the original _graph to the
	* _currentGraph.
	*/

	void begin(); /*
	* Create the environment variable _env.
	*/

	void createMasterProblem(); /*
	* Instanciate the master problem.
	* Create _masterModel, _masterObj, _masterVector and _masterSolver in
	* _env. Constraints are deducted from the _currentGraph and initial
	* columns are chosen by the _CM if its table is not empty.
	* It does NOT solve the master problem.
	*/

	void createGeneratorProblem(); /*
	* Instanciate the generator problem.
	* Create _generatorModel, _generatorObj, _generatorVector and 
	* _generatorSolver in _env. Constraints are deducted from the 
	* _currentGraph.
	* Set _genMode to SELF.
	* If you plan to use your own column-generator, then do NOT 
	* call this method. Call setGenerator() instead.
	*/

	
	//void setGenerator(Generator g); 
	/*
	* Use the g function as _generator and set _genMode to EXTERN. 
	*/

	void solve(); /*
	*  >> Wrapper function <<
	*
	* Call either _selfSolve() or _externSolve() depending on the value of
	* _genMode.
	*
	* Both wrapped functions do :
	* Solve the node and retrieve both _lb and _ub by column generation.
	* The solution obtained here is necesseraly fractional but can be
	* integer.
	* Columns generated by this method are stored and columns with positive
	* decision value by the end are added to the _CM. 
	*/

	Solution retrieveSolution() const; /*
	* Current solution is retrieved and returned as a Solution.
	*/

	void end(); /*
	* Destroy the environment variable _env and all the solver-related
	* variables.
	*/	

	private:
	void _selectBranch(int* u, int* v); /*
	* Fill any node with the value of -1 by following the rules of
	* E. Malaguti, M. Monaci and P. Toth 's paper :
	* "An exact approach for the Vertex Coloring Problem", 2010.
	* Use the attribute _s. Call retrieveSolution() if _s is NULL.
	*/

	void _selfSolve();   // See solve() for more infos on both 
	void _externSolve(); // _selfSolve() and _externSolve()

	/// GETTERS & SETTERS ///
	public:
	int                 getID()       const;
	float               getUB()       const;
	float               getLB()       const;
	BP_node*            getParent()   const;
	vector<BP_node*>    getChildren() const; 
	bp::NodeStatus      getStatus()   const;
	BP_graph*           getGraph()    const;
	vector<float>       getVec()      const;
	vector<vector<int>> getCol()      const;
	float               getUB2()      const;
	float               getLB2()      const;

	void             setStatus(bp::NodeStatus ns);
};



//============================================================================//
//====// Other Functions //===================================================//



//============================================================================//

#endif
